## Koнтролна работа 1

### Задача 1
Реализирайте клас `Pixel`, който има следните атрибути:
* `int red` - стойност на червената компонента на цвета му `[0,255]`
* `int green` - стойност на зелената компонента на цвета му `[0,255]`
* `int blue` - стойност на синята компонента на цвета му `[0,255]`

Реализирайте следните методи:
* Конструктор без параметри
* Конструктор с 3 параметъра  - (R, G, B)
* Подходящи getters и setters методи за всички атрибути
* Метод `void convertToGrayscale()`, който преобразува пиксела от RGB в Grayscale, като
използвате следната формула `0.2126*red + 0.7152*blue + 0.0722*green`. Тази стойност се присвоява и
на трите компоненти на пиксела (т.е. те са равни след конвертирането)

### Задача 2
Реализирайте клас `ColoredLine`, който има следните атрибути:
* `pixels` - динамичен масив от обекти от клас `Pixel`
* `int count` - брой пиксели в масива

Реализирайте следните методи:
* Конструктор без параметри
* Конструктор с 2 параметъра - масив от пиксели и бройката им
* Copy конструктор
* Деструктор
* Метод `void redHistogram(int* result)`, който смята хистограмата на червения цвят. Това е
масив с индекси от 0 до 255, като на съответен индекс `i` трябва да стои броя на пикселите,
които имат червена компонента със стойност `i`. Резултата нека се запише в масива `result`,
който ще бъде достатъчно голям.
* Метод `void greenHistogram(int* result)`
* Метод `void blueHistogram(int* result)`
* Метод `void convertToGrayscale`, който конвертира всички пиксели към Grayscale

### Задача 3
Реализирайте клас `Tree`, който представлява не-програмистко дърво
(ами такова в гората) със следните атрибути:
* `int height` - височина на дървото в метри
* `int age` - на колко години е дървото
* `int type` - тип на дървото - може да е широколистно или иглолистно
* `double leaves_area` - обща площ на листата на дървото в квадратни метри

Реализирайте следните методи:
* Конструктор без параметри
* Конструктор с 4-те параметъра
* Подходящи getters и setters методи за всички атрибути
* Метод `double getOxygenReplenish()`, който връща кислорода (в кубични сантиметри), който дървото би възобновило
във въздуха за едно денонощие. Той се смята по формулата `0.004*leaves_area` ако дървото е иглолистно 
и `0.0375*leaves_area` ако дървото е широколистно.

### Задача 4
Реализирайте клас `Forest`, която представлява масив от дървета
със следните атрибути:
* `trees` - динамичен масив от обекти от тип `Tree`
* `count` - брой дървета в гората (масива)

Реализирайте следните методи:
* Конструктор без параметри
* Конструктор с 2 параметъра - масив от дървета и бройката им
* Copy конструктор
* Деструктор
* Метод `double getOxygenReplenish()`, който връща кислорода възобновен от всичките дървета в гората за едно денонощие
* Метод `Tree getOldestTree()`, който връща по копие дървото в гората, което е най-старо
* Метод `Tree getBestTree()`, който връща най-доброто дърво в гората, като избора на най-добро дърво е това, за което
стойността `getOxygenReplenish() / age` е най-голяма



## Контролно 2
### Задача 1

Да се имплементира клас Hero, който има: 
* name - име на героя - динамичен char масив (не може да използвате std::string) 
*  base_attack - базова атака на героя - естествено число от 1 до 100 
*  health - жизнени точки на героя - естествено число от 1 до 100 
*  метод take_damage, който приема естествено число от 1 до 100, с което да намали health на героя 
*  метод take_healing, който приема естествено число от 1 до 100, с което да увеличи health на героя 
*  метод get_attack - който връща base_attack

Клас Warrior, който наследява Hero и освен това има: 
* crit - процентен шанс да удари двойно по силно - естествено число от 1 до 100 
*  clan - име на клан на война - динамичен char масив (не може да използвате std::string) 
*  метод get_attack - който връща base_attack на война, а в crit процента от случаите върнатия резултат трябва да е base_attack*2 (резултата от rand() % 10 е равен на 0 в 10% от случаите)

Клас Wizard, който наследява Hero и освен това има: 
* drain - процентен шанс при удар, магьосника да увеличи своя health с половината от атаката си 
* rang - име на ранга на магьосника - динамичен char масив (не може да използвате std::string)
* метод get_attack - който връща base_attack на магьосника и в drain процента от случаите, преди да върне атаката, трябва да увеличи жизнените точки с половината от base_attack

Напишете канонична четворка за всеки от горните класове.

Клас Game, който представлява игра между 2 героя. В конструктора си приема 2 указателя към обекти от клас Hero и при извикване на метода run на Game обект да се разиграва битка между двамата герои. Избира се на случаен принцип кой герой напада първи. Докато не свършат жизнените точки на някой от героите: 
* напада героят, чийто ред е в момента - взима се атака му и с нея се намаляват жизнените точки на другия герой 
* принтира се какво се е случило на този ход Накрая се принтира (разбира се) победителя в играта.

Бонус задача

Да се имплементира опашка от цели числва (queue, FIFO) използвайки динамичен int масив.
